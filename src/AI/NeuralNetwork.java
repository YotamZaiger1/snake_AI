package AI;

public class NeuralNetwork {
    private final Matrix[] wights;
    private final Matrix[] biases;
    private final int[] layerSizes;

    private Matrix outputVector;

    public NeuralNetwork(int... layerSizes){
        if (layerSizes == null || layerSizes.length < 2) {
            throw new RuntimeException("There must be at least 2 layers.");
        }

        this.layerSizes = layerSizes;
        this.wights = new Matrix[layerSizes.length - 1];
        this.biases = new Matrix[layerSizes.length - 1];
        this.outputVector = new Matrix(layerSizes[layerSizes.length - 1], 1);
    }

    public NeuralNetwork(Matrix[] wights, Matrix[] biases){
        if (wights == null || wights.length == 0 || biases == null || biases.length != wights.length) {
            throw new RuntimeException("Wights must contain at least 1 matrix. And biases must match wights length.");
        }

        this.wights = wights;
        this.biases = biases;
        this.layerSizes = new int[wights.length + 1];
        this.layerSizes[0] = wights[0].cols;

        for (int i = 1; i < wights.length + 1; i++) {
            if (i != wights.length && wights[i - 1].rows != wights[i].cols) {
                throw new RuntimeException("Matrices sizes do not match.");
            }
            this.layerSizes[i] = wights[i - 1].rows;
        }
        this.outputVector = new Matrix(layerSizes[layerSizes.length - 1], 1);
    }

    private double activationFunction(double x){
        if (x < 0) return 0d;
        return x;
    }

    /**
     * @return The index of the maximum output according to an input-vector.
     * Also the output-vector is being stored at {@code this.outputVector}.
     */
    public int predict(Matrix inputVector){
        // TODO: check if works
        for (int i = 0; i < wights.length; i++) {
            if (biases[i] == null){
                System.out.println("hi");
            }
            inputVector = inputVector.plus(biases[i]);

            Matrix wight = wights[i];
            inputVector = wight.mul(inputVector);
            for (int j = 0; j < inputVector.cols; j++) {
                inputVector.setXY(j, 0, activationFunction(inputVector.getXY(j, 0)));
            }
        }
        outputVector = inputVector;
        double max = outputVector.getXY(0, 0);
        int maxIndex = 0;
        for (int i = 1; i < outputVector.rows; i++) {
            double val = outputVector.getXY(i, 0);
            if (val > max) {
                max = val;
                maxIndex = i;
            }
        }
        return maxIndex;
    }

    public NeuralNetwork mutated(double mutationRate, double mutationStrength){
        NeuralNetwork mutation = new NeuralNetwork(this.layerSizes);
        for (int i = 0; i < wights.length; i++) {
            mutation.wights[i] = wights[i].mutated(mutationRate, mutationStrength);
            mutation.biases[i] = biases[i].mutated(mutationRate, mutationStrength);
        }
        return mutation;
    }

    /**
     * Returns a random population. The wights will be random numbers, generated by the {@code Matrix.randomMatrix} function.
     * @param populationSize Size of the population.
     * @param layerSizes Sizes of the layers in the {@code NeuralNetwork} agents.
     * @return A random population.
     */
    public static NeuralNetwork[] generateFirstPopulation(int populationSize, int[] layerSizes){
        NeuralNetwork[] population = new NeuralNetwork[populationSize];
        for (int i = 0; i < populationSize; i++) {
            NeuralNetwork agent = new NeuralNetwork(layerSizes);
            for (int j = 0; j < layerSizes.length - 1; j++) {
                agent.wights[j] = Matrix.randomMatrix(layerSizes[j + 1], layerSizes[j]);
                agent.biases[j] = Matrix.randomMatrix(layerSizes[j], 1);
            }
            population[i] = agent;
        }
        return population;
    }

    public NeuralNetwork clone(){
        NeuralNetwork clone = new NeuralNetwork(this.layerSizes);
        for (int i = 0; i < this.wights.length; i++) {
            clone.wights[i] = this.wights[i].clone();
            clone.biases[i] = this.biases[i].clone();
        }
        for (Matrix bias: clone.biases) {
            if (bias == null) {
                System.out.println("null bias");
            }
        }
        return clone;
    }

    @Override
    public String toString(){
        StringBuilder stringBuilder = new StringBuilder();
        for (Matrix matrix: wights) {
            stringBuilder.append(matrix.toString()).append("\n\n");
        }
        return stringBuilder.toString();
    }

    public Matrix[] getWights() {
        return wights.clone();
    }

    public Matrix getOutputVector() {
        return outputVector.clone();
    }

    public int[] getLayerSizes() {
        return layerSizes.clone();
    }
}
